<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Conveyor Logic Visualizer (自動接続版)</title>
  <style>
    body { font-family: monospace; background: #1a1a2e; color: #eee; padding: 20px; }
    .grid-container { display: inline-block; }
    .cell {
      width: 60px; height: 60px;
      background: #2a2a4a;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; position: relative;
    }
    .cell:hover { background: #3a3a5a; }
    .cell.conveyor { background: #4a4a6a; }
    .cell.corner-left { background: #6a6a4a; }
    .cell.corner-right { background: #4a6a6a; }
    .cell.t-junction { background: #6a4a6a; }
    .cell.splitter { background: #4a6a4a; }
    .cell.cross { background: #6a6a6a; }
    .info { margin: 20px 0; padding: 10px; background: #2a2a4a; max-width: 800px; white-space: pre-wrap; font-size: 12px; }
    .controls { margin: 10px 0; }
    button { padding: 8px 16px; margin: 4px; cursor: pointer; }
    button.active { background: #6a6aaa; color: white; }
    .legend { display: flex; gap: 20px; margin: 10px 0; flex-wrap: wrap; }
    .legend-item { display: flex; align-items: center; gap: 8px; }
    .legend-color { width: 20px; height: 20px; }
    .shape-display { font-size: 9px; position: absolute; bottom: 1px; right: 2px; color: #aaa; }
    .coord-display { font-size: 8px; position: absolute; top: 1px; left: 2px; color: #666; }
    .col-labels { display: flex; gap: 2px; margin-left: 32px; margin-bottom: 2px; }
    .col-label { width: 60px; text-align: center; color: #888; font-weight: bold; }
    .row-container { display: flex; }
    .row-label { width: 30px; display: flex; align-items: center; justify-content: center; color: #888; font-weight: bold; }
  </style>
</head>
<body>
  <h2>Conveyor Logic Visualizer (自動接続版)</h2>

  <div class="legend">
    <div class="legend-item"><div class="legend-color" style="background:#4a4a6a"></div>Straight (S)</div>
    <div class="legend-item"><div class="legend-color" style="background:#6a6a4a"></div>CornerLeft (L)</div>
    <div class="legend-item"><div class="legend-color" style="background:#4a6a6a"></div>CornerRight (R)</div>
    <div class="legend-item"><div class="legend-color" style="background:#6a4a6a"></div>TJunction (T)</div>
    <div class="legend-item"><div class="legend-color" style="background:#4a6a4a"></div>Splitter (P)</div>
    <div class="legend-item"><div class="legend-color" style="background:#6a6a6a"></div>Cross (X)</div>
  </div>

  <div class="controls">
    <span>設置方向: </span>
    <button id="btn-North" onclick="setDirection('North')">↑ North</button>
    <button id="btn-South" onclick="setDirection('South')">↓ South</button>
    <button id="btn-East" onclick="setDirection('East')">→ East</button>
    <button id="btn-West" onclick="setDirection('West')">← West</button>
    <button onclick="clearAll()" style="margin-left:20px; background:#633;">Clear All</button>
  </div>

  <div class="grid-container">
    <div class="col-labels" id="col-labels"></div>
    <div id="grid-rows"></div>
  </div>

  <div class="info" id="info">クリックしてコンベアを設置（右クリックで削除）
自動接続: 後ろから入力があり、前方に接続先がない場合、左右の接続先へ自動的に曲がります</div>

  <div class="info">
    <h3>自動接続ロジック</h3>
    <pre>
1. 後ろからの入力を確認
2. 前方に接続先（自分を受け入れるコンベア）があるか確認
3. 前方に接続先がなく、左右に接続先があれば曲がる
4. 左右両方から入力があればT字路

例: D3↑ → C3 → C4→ の場合
  - C3は後ろ(D3)から入力あり
  - C3の前方(B3)には接続先なし
  - C3の右(C4)に接続先あり → CornerRight
    </pre>
  </div>

<script>
const GRID_SIZE = 7;
const conveyors = {}; // key: "x,z" -> {direction, shape, outputDir}

const DIRECTIONS = {
  North: { dx: 0, dz: -1 },
  South: { dx: 0, dz: 1 },
  East:  { dx: 1, dz: 0 },
  West:  { dx: -1, dz: 0 }
};

const LEFT = { North: 'West', East: 'North', South: 'East', West: 'South' };
const RIGHT = { North: 'East', East: 'South', South: 'West', West: 'North' };
const OPPOSITE = { North: 'South', South: 'North', East: 'West', West: 'East' };
const ROW_LABELS = 'ABCDEFGHIJ'.split('');

let currentDirection = 'North';

function setDirection(dir) {
  currentDirection = dir;
  document.querySelectorAll('.controls button[id^="btn-"]').forEach(b => b.classList.remove('active'));
  document.getElementById('btn-' + dir).classList.add('active');
}

function getKey(x, z) { return `${x},${z}`; }
function getConveyorAt(x, z) { return conveyors[getKey(x, z)]; }
function coordStr(x, z) { return `(${x},${ROW_LABELS[z]})`; }

function getPos(x, z, dir) {
  const d = DIRECTIONS[dir];
  return { x: x + d.dx, z: z + d.dz };
}

// コンベア(ox,oz)の出力が(tx,tz)に向かうか
// ※計算済みのoutputDir/outputDirsを使用
function outputsTo(ox, oz, tx, tz) {
  const conv = getConveyorAt(ox, oz);
  if (!conv) return false;

  // 複数出力（Splitter等）の場合
  if (conv.outputDirs) {
    for (const dir of conv.outputDirs) {
      const d = DIRECTIONS[dir];
      if (ox + d.dx === tx && oz + d.dz === tz) return true;
    }
    return false;
  }

  // 単一出力の場合
  const outDir = conv.outputDir || conv.direction;
  const d = DIRECTIONS[outDir];
  return ox + d.dx === tx && oz + d.dz === tz;
}

// (ox,oz)のコンベアが(tx,tz)からの入力を受け入れられるか
function canReceiveFrom(ox, oz, tx, tz) {
  const conv = getConveyorAt(ox, oz);
  if (!conv) return false;
  const dir = conv.direction;
  // 入力は後ろ、左、右から可能（前からは不可）
  const backPos = getPos(ox, oz, OPPOSITE[dir]);
  const leftPos = getPos(ox, oz, LEFT[dir]);
  const rightPos = getPos(ox, oz, RIGHT[dir]);
  return (backPos.x === tx && backPos.z === tz) ||
         (leftPos.x === tx && leftPos.z === tz) ||
         (rightPos.x === tx && rightPos.z === tz);
}

// シンプル版: 入力方向で形状が決まる
function calculateShapeAndOutput(x, z, direction) {
  // 自分から見た4方向の位置
  const backDir = OPPOSITE[direction];
  const leftDir = LEFT[direction];
  const rightDir = RIGHT[direction];
  const frontDir = direction;

  const backPos = getPos(x, z, backDir);
  const leftPos = getPos(x, z, leftDir);
  const rightPos = getPos(x, z, rightDir);
  const frontPos = getPos(x, z, frontDir);

  // 各方向からの入力をチェック（その方向のコンベアが自分に向かって出力しているか）
  const hasBackInput = outputsTo(backPos.x, backPos.z, x, z);
  const hasLeftInput = outputsTo(leftPos.x, leftPos.z, x, z);
  const hasRightInput = outputsTo(rightPos.x, rightPos.z, x, z);
  const hasFrontInput = outputsTo(frontPos.x, frontPos.z, x, z);

  const inputCount = [hasBackInput, hasLeftInput, hasRightInput, hasFrontInput].filter(Boolean).length;

  // 左右前方の「待ち受け」をチェック（隣のコンベアが自分からの入力を受け入れ可能か）
  const leftConv = getConveyorAt(leftPos.x, leftPos.z);
  const rightConv = getConveyorAt(rightPos.x, rightPos.z);
  const frontConv = getConveyorAt(frontPos.x, frontPos.z);

  // 「待ち受け」= 隣のコンベアが自分からの入力を受け入れ可能（後ろ・左・右から）
  // ただし、既に自分に出力しているコンベアは待ち受けではない
  const leftWaiting = leftConv && !hasLeftInput && canReceiveFrom(leftPos.x, leftPos.z, x, z);
  const rightWaiting = rightConv && !hasRightInput && canReceiveFrom(rightPos.x, rightPos.z, x, z);
  const frontWaiting = frontConv && !hasFrontInput && canReceiveFrom(frontPos.x, frontPos.z, x, z);

  const waitCount = [leftWaiting, rightWaiting, frontWaiting].filter(Boolean).length;

  // 入力2+
  if (inputCount >= 2) {
    const inputDirs = [];
    if (hasBackInput) inputDirs.push(backDir);
    if (hasLeftInput) inputDirs.push(leftDir);
    if (hasRightInput) inputDirs.push(rightDir);
    if (hasFrontInput) inputDirs.push(frontDir);

    // 待ち受け2+ → Cross（合流+分岐）
    if (waitCount >= 2) {
      const outputDirs = [];
      if (frontWaiting) outputDirs.push(frontDir);
      if (leftWaiting) outputDirs.push(leftDir);
      if (rightWaiting) outputDirs.push(rightDir);
      return { shape: 'Cross', outputDir: direction, inputDirs: inputDirs, outputDirs: outputDirs };
    }

    // 待ち受け1 → TJunction（合流、単一出力）
    if (waitCount === 1) {
      const outDir = frontWaiting ? frontDir : (rightWaiting ? rightDir : leftDir);
      return { shape: 'TJunction', outputDir: outDir, inputDirs: inputDirs };
    }

    // 待ち受け0 → TJunction（デフォルト出力）
    return { shape: 'TJunction', outputDir: direction, inputDirs: inputDirs };
  }

  // 入力1
  if (inputCount === 1) {
    // 後ろから入力
    if (hasBackInput) {
      // 2箇所以上が待ち受け → Splitter
      if (waitCount >= 2) {
        const outputDirs = [];
        if (frontWaiting) outputDirs.push(frontDir);
        if (leftWaiting) outputDirs.push(leftDir);
        if (rightWaiting) outputDirs.push(rightDir);
        return { shape: 'Splitter', outputDir: direction, inputDir: backDir, outputDirs: outputDirs };
      }
      // 右だけ待ち受け → CornerRight
      if (rightWaiting) {
        return { shape: 'CornerRight', outputDir: rightDir, inputDir: backDir };
      }
      // 左だけ待ち受け → CornerLeft
      if (leftWaiting) {
        return { shape: 'CornerLeft', outputDir: leftDir, inputDir: backDir };
      }
      // 前方に出力 → Straight
      return { shape: 'Straight', outputDir: direction, inputDir: backDir };
    }
    // 左から入力
    if (hasLeftInput) {
      // 前方と右に待ち受け → Splitter（左から入って前方と右へ分岐）
      if (frontWaiting && rightWaiting) {
        return { shape: 'Splitter', outputDir: direction, inputDir: leftDir, outputDirs: [frontDir, rightDir] };
      }
      // 右に待ち受け（前方に待ち受けなし）→ CornerRight風（左から入って右へ）
      if (rightWaiting && !frontWaiting) {
        return { shape: 'CornerRight', outputDir: rightDir, inputDir: leftDir };
      }
      // 前方に待ち受け → CornerLeft（左から入って前方へ）
      return { shape: 'CornerLeft', outputDir: direction, inputDir: leftDir };
    }
    // 右から入力
    if (hasRightInput) {
      // 前方と左に待ち受け → Splitter（右から入って前方と左へ分岐）
      if (frontWaiting && leftWaiting) {
        return { shape: 'Splitter', outputDir: direction, inputDir: rightDir, outputDirs: [frontDir, leftDir] };
      }
      // 左に待ち受け（前方に待ち受けなし）→ CornerLeft風（右から入って左へ）
      if (leftWaiting && !frontWaiting) {
        return { shape: 'CornerLeft', outputDir: leftDir, inputDir: rightDir };
      }
      // 前方に待ち受け → CornerRight（右から入って前方へ）
      return { shape: 'CornerRight', outputDir: direction, inputDir: rightDir };
    }
    // 前から入力（向かい合い）→ Straight（入力を受けるだけ）
    if (hasFrontInput) {
      return { shape: 'Straight', outputDir: direction, inputDir: frontDir };
    }
  }

  // 入力0 → Straight（設置向きに出力）
  return { shape: 'Straight', outputDir: direction, inputDir: backDir };
}

function updateAllShapes() {
  for (let i = 0; i < 20; i++) {
    for (const key in conveyors) {
      const [x, z] = key.split(',').map(Number);
      const conv = conveyors[key];
      const result = calculateShapeAndOutput(x, z, conv.direction);
      conv.shape = result.shape;
      conv.outputDir = result.outputDir;
      conv.outputDirs = result.outputDirs || null;
      conv.inputDir = result.inputDir;
      conv.inputDirs = result.inputDirs || null;
    }
  }
}

// 接続面マーカーを追加
function addConnectionMarkers(cell, inputDir, outputDir, inputDirs, outputDirs) {
  // 入力マーカー（緑）- 複数対応
  if (inputDirs && inputDirs.length > 0) {
    for (const dir of inputDirs) {
      const inMarker = document.createElement('div');
      inMarker.style.cssText = 'position:absolute; background:#4f4; z-index:1;';
      positionMarker(inMarker, dir);
      cell.appendChild(inMarker);
    }
  } else if (inputDir) {
    const inMarker = document.createElement('div');
    inMarker.style.cssText = 'position:absolute; background:#4f4; z-index:1;';
    positionMarker(inMarker, inputDir);
    cell.appendChild(inMarker);
  }

  // 出力マーカー（オレンジ）- 複数対応
  if (outputDirs && outputDirs.length > 0) {
    for (const dir of outputDirs) {
      const outMarker = document.createElement('div');
      outMarker.style.cssText = 'position:absolute; background:#f84; z-index:1;';
      positionMarker(outMarker, dir);
      cell.appendChild(outMarker);
    }
  } else if (outputDir) {
    const outMarker = document.createElement('div');
    outMarker.style.cssText = 'position:absolute; background:#f84; z-index:1;';
    positionMarker(outMarker, outputDir);
    cell.appendChild(outMarker);
  }
}

function positionMarker(el, dir) {
  const size = '20px';
  const thick = '6px';
  switch(dir) {
    case 'North':
      el.style.top = '0'; el.style.left = '50%'; el.style.transform = 'translateX(-50%)';
      el.style.width = size; el.style.height = thick;
      break;
    case 'South':
      el.style.bottom = '0'; el.style.left = '50%'; el.style.transform = 'translateX(-50%)';
      el.style.width = size; el.style.height = thick;
      break;
    case 'East':
      el.style.right = '0'; el.style.top = '50%'; el.style.transform = 'translateY(-50%)';
      el.style.width = thick; el.style.height = size;
      break;
    case 'West':
      el.style.left = '0'; el.style.top = '50%'; el.style.transform = 'translateY(-50%)';
      el.style.width = thick; el.style.height = size;
      break;
  }
}

function renderGrid() {
  const colLabels = document.getElementById('col-labels');
  colLabels.innerHTML = '';
  for (let x = 0; x < GRID_SIZE; x++) {
    const label = document.createElement('div');
    label.className = 'col-label';
    label.textContent = x;
    colLabels.appendChild(label);
  }

  const gridRows = document.getElementById('grid-rows');
  gridRows.innerHTML = '';

  for (let z = 0; z < GRID_SIZE; z++) {
    const rowContainer = document.createElement('div');
    rowContainer.className = 'row-container';

    const rowLabel = document.createElement('div');
    rowLabel.className = 'row-label';
    rowLabel.textContent = ROW_LABELS[z];
    rowContainer.appendChild(rowLabel);

    const gridRow = document.createElement('div');
    gridRow.style.display = 'flex';
    gridRow.style.gap = '2px';

    for (let x = 0; x < GRID_SIZE; x++) {
      const cell = document.createElement('div');
      cell.className = 'cell';

      const coordDiv = document.createElement('span');
      coordDiv.className = 'coord-display';
      coordDiv.textContent = `${x},${ROW_LABELS[z]}`;
      cell.appendChild(coordDiv);

      const conv = getConveyorAt(x, z);
      if (conv) {
        cell.classList.add('conveyor');
        const shapeClass = conv.shape.replace(/([A-Z])/g, '-$1').toLowerCase().substring(1);
        cell.classList.add(shapeClass);

        addConnectionMarkers(cell, conv.inputDir, conv.outputDir, conv.inputDirs, conv.outputDirs);

        const shapeLabel = document.createElement('span');
        shapeLabel.className = 'shape-display';
        shapeLabel.textContent = conv.shape[0] === 'C' ? conv.shape[6] : conv.shape[0];
        cell.appendChild(shapeLabel);
      }

      cell.onclick = () => toggleConveyor(x, z);
      cell.oncontextmenu = (e) => { e.preventDefault(); removeConveyor(x, z); };
      gridRow.appendChild(cell);
    }

    rowContainer.appendChild(gridRow);
    gridRows.appendChild(rowContainer);
  }
}

function toggleConveyor(x, z) {
  const key = getKey(x, z);
  if (conveyors[key]) {
    const dirs = ['North', 'East', 'South', 'West'];
    const idx = dirs.indexOf(conveyors[key].direction);
    conveyors[key].direction = dirs[(idx + 1) % 4];
  } else {
    conveyors[key] = { direction: currentDirection, shape: 'Straight', outputDir: currentDirection };
  }
  updateAllShapes();
  renderGrid();
  showDebugInfo();
}

function removeConveyor(x, z) {
  delete conveyors[getKey(x, z)];
  updateAllShapes();
  renderGrid();
  showDebugInfo();
}

function clearAll() {
  for (const key in conveyors) delete conveyors[key];
  renderGrid();
  document.getElementById('info').textContent = 'Cleared';
}

function showDebugInfo() {
  let info = '設置されたコンベア:\n';
  for (const key in conveyors) {
    const [x, z] = key.split(',').map(Number);
    const conv = conveyors[key];
    const outDirs = conv.outputDirs ? conv.outputDirs.join(',') : conv.outputDir;
    info += `  ${coordStr(x,z)} dir=${conv.direction} → shape=${conv.shape}, out=${outDirs}\n`;
  }
  document.getElementById('info').textContent = info;
}

setDirection('North');
renderGrid();
</script>
</body>
</html>
