# ゲームデザインパターン集

**目的**: レシピ、クエスト、進行システムなどを設計・評価するための基準

---

## 使い方

1. 新機能を設計する際、関連するパターンを確認
2. 評価チェックリストで設計を検証
3. アンチパターンに該当していないか確認

---

## Part 1: 進行パターン

### P1. 段階的複雑化（Gradual Complexity）

**原則**: 新しいシステムは小さく導入し、徐々に深める

```
良い例:
  鉄鉱石 → 鉄インゴット（単純）
  ↓
  鉄インゴット + 銅インゴット → 歯車（2入力）
  ↓
  歯車 + 電子回路 + フレーム → 機械（複合）

悪い例:
  いきなり5種類の素材が必要なレシピから始まる
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| 最初のレシピは1-2入力か | |
| 新素材は既存素材から派生しているか | |
| 複雑なレシピの前に構成要素を学べるか | |

---

### P2. 明確なマイルストーン（Clear Milestones）

**原則**: プレイヤーが「次の目標」を常に認識できる

```
良い例:
  Phase 1: 手動採掘 → 目標: 最初の機械を作る
  Phase 2: 基本自動化 → 目標: 電力網を構築
  Phase 3: 物流 → 目標: ベルトコンベアで接続

悪い例:
  「自由に遊んでください」（目標なし）
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| 各フェーズに明確なゴールがあるか | |
| 次のフェーズへの道筋が見えるか | |
| 達成時にフィードバックがあるか | |

---

### P3. 複数経路（Multiple Paths）

**原則**: 詰まったときの迂回路を用意する

```
良い例:
  電子回路が作れない
  → 代わりに機械部品ルートで進める
  → 後で電子回路に戻ってくる

悪い例:
  青サイエンス（石油）がボトルネック
  → 他に進める道がない
  → ここで詰まって離脱
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| 各フェーズに2つ以上の進行ルートがあるか | |
| 1つのボトルネックで全体が止まらないか | |
| 難しい要素をスキップして後で戻れるか | |

---

### P4. 報酬の即時性（Immediate Rewards）

**原則**: 作業の結果がすぐに見える

```
良い例:
  機械を置く → すぐ動き出す → 製品が出てくる

悪い例:
  機械を置く → 5分待つ → やっと1個できる
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| 配置後すぐに動作が見えるか | |
| 最初の成果物は30秒以内に出るか | |
| 待機時間中に別のタスクがあるか | |

---

## Part 2: レシピ設計パターン

### R1. 入出力バランス（I/O Balance）

**原則**: 副産物は必ず消費先を持つ

```
良い例:
  原油精製 → ガソリン + プラスチック
  ガソリン → 発電機で消費
  プラスチック → 電子部品で消費

悪い例:
  原油精製 → ガソリン + 重油
  重油の使い道がない → ライン詰まり
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| 全ての副産物に用途があるか | |
| 副産物の消費速度は生産速度と釣り合うか | |
| 余剰時の処理方法があるか（焼却、リサイクル） | |

---

### R2. レシピ比率の美しさ（Ratio Elegance）

**原則**: 計算しやすい比率を優先

```
良い例:
  鉄板2 + 銅線1 → 回路1（2:1:1）
  歯車1 + 回路1 → モーター1（1:1:1）

悪い例:
  鉄板3 + 銅線7 → 回路2（端数が出る）
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| 入出力比が簡単な整数か | |
| ライン設計時に端数が出にくいか | |
| 複数レシピを組み合わせた時の比率は？ | |

---

### R3. 深さの制限（Depth Limit）

**原則**: レシピチェーンは5階層以内

```
良い例:
  鉱石 → インゴット → 板 → 部品 → 製品（4階層）

悪い例:
  鉱石 → インゴット → 板 → 棒 → 線 → コイル → 回路 → ...（8階層以上）
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| 最終製品までの最大階層数は？ | |
| 中間素材が多すぎないか | |
| 各階層に意味のある変換があるか | |

---

### R4. 視認性（Recipe Visibility）

**原則**: レシピの関係が視覚的に理解できる

```
良い例:
  ツリー表示で依存関係が一目瞭然
  色分けでカテゴリがわかる

悪い例:
  フラットなリストで関係がわからない
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| レシピツリーを視覚化できるか | |
| 逆引き（この素材は何に使う？）ができるか | |
| ボトルネックが視覚的にわかるか | |

---

## Part 3: クエスト設計パターン

### Q1. 教育的順序（Educational Order）

**原則**: クエストが自然にゲームを教える

```
良い例:
  Q1: 木を切ってみよう（基本操作）
  Q2: 作業台を作ろう（クラフト）
  Q3: 掘削機を作ろう（自動化の入口）
  Q4: ベルトでつなごう（物流）

悪い例:
  Q1: 複雑な機械を作れ（いきなり難しい）
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| クエスト順に従えば自然に学べるか | |
| 各クエストは1つの概念を教えているか | |
| 前のクエストの知識が次に活きるか | |

---

### Q2. 適切な報酬（Appropriate Rewards）

**原則**: 努力に見合った報酬を与える

```
良い例:
  簡単なクエスト → 小さな報酬（素材少量）
  難しいクエスト → 大きな報酬（新機能解放）

悪い例:
  30分かかるクエスト → 鉄鉱石10個（割に合わない）
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| 報酬は努力に比例しているか | |
| 報酬は次の進行に役立つか | |
| 達成感を演出しているか（音、視覚効果） | |

---

### Q3. 選択可能性（Optional Quests）

**原則**: 必須クエストと任意クエストを分ける

```
良い例:
  メインクエスト: ロケット発射（必須）
  サイドクエスト: 効率100%達成（任意チャレンジ）

悪い例:
  全てのクエストが必須で自由度がない
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| メインとサイドが区別されているか | |
| サイドをスキップしても進行できるか | |
| チャレンジ好きへの任意目標があるか | |

---

### Q4. コンテキストの提供（Context Provision）

**原則**: なぜこれをするのか理由を示す

```
良い例:
  「電力が不足しています。発電機を増設しましょう」
  → 問題 → 解決策 の流れ

悪い例:
  「発電機を5個作れ」
  → なぜ5個？理由がわからない
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| クエストの目的が説明されているか | |
| ゲーム世界の文脈に合っているか | |
| 完了後に何が変わるかわかるか | |

---

## Part 4: UI/UXパターン

### U1. 情報の階層化（Information Hierarchy）

**原則**: 重要な情報ほど目立たせる

```
優先度1: 緊急事態（電力不足、ライン停止）
優先度2: 進行状況（クエスト、生産量）
優先度3: 詳細情報（統計、設定）
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| 緊急事態は即座に気づけるか | |
| 通常プレイ中のHUDは最小限か | |
| 詳細は必要な時だけ表示されるか | |

---

### U2. 操作の一貫性（Consistent Controls）

**原則**: 同じ操作は同じ結果を生む

```
良い例:
  左クリック = 常に配置/選択
  右クリック = 常にキャンセル/削除

悪い例:
  あるUIでは左クリックで確定
  別のUIでは左クリックでキャンセル
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| マウスボタンの役割は固定か | |
| キーボードショートカットは一貫しているか | |
| モードによって操作が変わらないか | |

---

### U3. 即時フィードバック（Instant Feedback）

**原則**: 全ての操作に視覚/聴覚フィードバック

```
良い例:
  配置 → 「カチッ」という音 + 設置アニメーション
  エラー → 赤く光る + 警告音

悪い例:
  何かを押したが、何が起きたかわからない
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| 全てのボタンに押下フィードバックがあるか | |
| 成功/失敗が明確に区別できるか | |
| 音と視覚が同期しているか | |

---

### U4. 元に戻せる操作（Reversible Actions）

**原則**: ミスからの回復を容易に

```
良い例:
  Ctrl+Z でUndo
  建設物は即座に解体可能
  解体した素材は100%回収

悪い例:
  一度置いたら動かせない
  解体すると素材が消える
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| Undo/Redo機能はあるか | |
| 解体・再配置は簡単か | |
| 素材のロスは最小限か | |

---

## Part 5: アンチパターン速見表

### 絶対に避ける

| パターン | 症状 | 対策 |
|----------|------|------|
| 仕事感 | 「やらされている」 | 早期自動化、達成演出 |
| 難易度の崖 | 特定ポイントで詰まる | 段階的導入、迂回路 |
| チュートリアル不足 | 何をすべきかわからない | 視覚ガイド、段階開放 |
| 副産物詰まり | ラインが止まる | 全副産物に用途 |

### 注意する

| パターン | 症状 | 対策 |
|----------|------|------|
| 終盤グラインド | スケールアップのみ | 終盤に新要素 |
| 移動コスト | 建設<移動 | 早期乗り物 |
| 待機時間 | 生産待ち | 並行タスク |
| 情報過多 | 圧倒される | 段階的表示 |

---

## Part 6: エディタUIパターン

### E1. ツールチップの完備（Complete Tooltips）

**原則**: 全てのボタン/アイコンにホバーで説明を表示

```
良い例:
  [🔧] ← ホバー → "設定を開く (Ctrl+,)"

悪い例:
  [🔧] ← ホバー → （何も表示されない）
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| 全ボタンにツールチップがあるか | |
| ショートカットキーも表示されているか | |
| 0.5秒程度の遅延で表示されるか | |

---

### E2. 深いUndo/Redo（Deep History）

**原則**: 100ステップ以上のUndo履歴を保持

```
良い例:
  Ctrl+Z で100回以上戻れる
  差分圧縮でメモリ効率化

悪い例:
  10ステップで履歴が消える
  Undo不可な操作がある
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| Undo履歴は100ステップ以上か | |
| 細かい粒度（個別操作単位）でUndoできるか | |
| 関連オブジェクトも一緒に復元されるか | |

---

### E3. キーボードショートカットの可視性（Visible Shortcuts）

**原則**: ショートカットはメニューに表示、標準に準拠

```
良い例:
  ファイル > 保存 (Ctrl+S)
  編集 > 元に戻す (Ctrl+Z)

悪い例:
  ショートカットが隠されている
  非標準のキー割り当て
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| メニューにショートカットが併記されているか | |
| Ctrl+S, Ctrl+Z等の標準に準拠しているか | |
| OS別に適切な修飾キーを表示しているか | |

---

### E4. ノードエディタの標準（Node Editor Standards）

**原則**: データフローは上→下または左→右、型は色分け

```
良い例:
  [入力] ─緑─→ [処理] ─青─→ [出力]
  互換性のないポート同士は接続不可

悪い例:
  フローの方向がバラバラ
  全てのワイヤーが同じ色
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| データフローの方向は一貫しているか | |
| 型ごとに色分けされているか | |
| 無効な接続は防止されているか | |
| 60fpsでズーム/パンが動作するか | |

---

### E5. 即時プレビュー（Instant Preview）

**原則**: 編集結果を即座に確認できる

```
良い例:
  レシピを編集 → リアルタイムでツリー更新
  色を変更 → プレビューに即反映

悪い例:
  保存しないと変更が見えない
  プレビューに別画面への遷移が必要
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| 編集がリアルタイムでプレビューに反映されるか | |
| 別画面に遷移せずに確認できるか | |
| 変更前/変更後の比較ができるか | |

---

### E6. 検索とフィルタ（Search and Filter）

**原則**: 大量のアイテムから素早く目的を見つける

```
良い例:
  Ctrl+K で検索ダイアログ
  カテゴリ別フィルタ
  最近使用したアイテムのリスト

悪い例:
  スクロールして探すしかない
  検索機能がない
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| グローバル検索機能があるか | |
| カテゴリ/タグでフィルタできるか | |
| 最近使用したアイテムにアクセスしやすいか | |

---

## Part 7: エディタアンチパターン速見表

### 絶対に避ける

| パターン | 症状 | 対策 |
|----------|------|------|
| 一貫性欠如 | 同じ操作が違う結果 | 操作ルール統一 |
| 機能の迷路 | 探すのに時間がかかる | 検索、論理的配置 |
| 情報過多 | 圧倒される | 段階的開示 |
| Blender症候群 | 暗記必須 | 視覚的UI優先 |

### 強く避ける

| パターン | 症状 | 対策 |
|----------|------|------|
| フィードバック欠如 | 反応がない | 即時フィードバック |
| 浅いUndo | ミスが戻せない | 100+ステップ |
| モード地獄 | 誤操作 | モード表示/削減 |
| チュートリアル不足 | 始められない | ガイド提供 |

---

## Part 8: 評価テンプレート

### レシピツリー評価

```markdown
## レシピツリー評価: [ツリー名]

### 基本情報
- 最大階層数:
- 総レシピ数:
- 原材料種類数:

### パターンチェック
| パターン | 適合 | 備考 |
|----------|------|------|
| P1. 段階的複雑化 | ☐ | |
| R1. 入出力バランス | ☐ | |
| R2. レシピ比率 | ☐ | |
| R3. 深さ制限 | ☐ | |
| R4. 視認性 | ☐ | |

### アンチパターンチェック
| アンチパターン | 該当 | 対策 |
|---------------|------|------|
| 難易度の崖 | ☐ | |
| 副産物詰まり | ☐ | |
| 終盤グラインド | ☐ | |

### 総合評価
-
```

### クエストツリー評価

```markdown
## クエストツリー評価: [ツリー名]

### 基本情報
- 総クエスト数:
- メインクエスト数:
- サイドクエスト数:

### パターンチェック
| パターン | 適合 | 備考 |
|----------|------|------|
| Q1. 教育的順序 | ☐ | |
| Q2. 適切な報酬 | ☐ | |
| Q3. 選択可能性 | ☐ | |
| Q4. コンテキスト | ☐ | |
| P2. 明確なマイルストーン | ☐ | |
| P3. 複数経路 | ☐ | |

### アンチパターンチェック
| アンチパターン | 該当 | 対策 |
|---------------|------|------|
| 仕事感 | ☐ | |
| 難易度の崖 | ☐ | |
| チュートリアル不足 | ☐ | |

### 総合評価
-
```

### エディタUI評価

```markdown
## エディタUI評価: [エディタ名]

### 基本情報
- 対象ユーザー:
- 主要機能:

### パターンチェック
| パターン | 適合 | 備考 |
|----------|------|------|
| E1. ツールチップ完備 | ☐ | |
| E2. 深いUndo/Redo | ☐ | |
| E3. ショートカット可視性 | ☐ | |
| E4. ノードエディタ標準 | ☐ | |
| E5. 即時プレビュー | ☐ | |
| E6. 検索とフィルタ | ☐ | |
| U2. 操作の一貫性 | ☐ | |
| U3. 即時フィードバック | ☐ | |

### アンチパターンチェック
| アンチパターン | 該当 | 対策 |
|---------------|------|------|
| 一貫性欠如 | ☐ | |
| 情報過多 | ☐ | |
| Blender症候群 | ☐ | |
| チュートリアル不足 | ☐ | |

### 総合評価
-
```

---

## Part 9: テストパターン

### T1. ECSユニットテスト（ECS Unit Testing）

**原則**: 個々のシステムをWorld直接操作でテスト

```rust
良い例:
  #[test]
  fn test_machine_production() {
      let mut app = App::new();
      app.add_systems(Update, production_system);

      // 初期状態セットアップ
      app.world.spawn((Machine::new(), Inventory::new()));

      // 100フレーム経過
      for _ in 0..100 { app.update(); }

      // 検証
      assert!(production_completed(&app));
  }

悪い例:
  統合テストのみ（個別システムをテストしない）
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| 各システムに個別テストがあるか | |
| 外部依存なしでテストできるか | |
| フレーム単位で検証できるか | |

---

### T2. リプレイシステム（Replay System）

**原則**: 入力を記録し、決定的に再生できる

```rust
良い例:
  struct Replay {
      seed: u64,         // 乱数シード固定
      inputs: Vec<(u64, Action)>,  // (フレーム, 操作)
  }
  // 同じReplayは常に同じ結果

悪い例:
  乱数シードが記録されていない
  フレーム番号なしで入力だけ記録
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| 入力記録・再生機能があるか | |
| 乱数シードが固定できるか | |
| 再生が決定的か（毎回同じ結果） | |

---

### T3. プロパティベーステスト（Property-Based Testing）

**原則**: 不変条件をランダム入力で検証

```rust
良い例:
  proptest! {
      #[test]
      fn inventory_never_negative(items in vec(any::<Item>(), 0..100)) {
          let mut inv = Inventory::new();
          for item in items { inv.add(item); }

          // 不変条件: 数量は常に0以上
          for slot in inv.slots() {
              prop_assert!(slot.count >= 0);
          }
      }
  }

悪い例:
  固定の入力パターンのみでテスト
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| 重要な不変条件が定義されているか | |
| proptestでランダム入力をテストしているか | |
| 境界条件が自動探索されているか | |

---

### T4. E2Eテスト（End-to-End Testing）

**原則**: 実際のUI操作をシミュレート

```javascript
良い例:
  // WebdriverIO + Tauri
  it('creates recipe', async () => {
      await $('#new-recipe-btn').click();
      await $('#recipe-name').setValue('Iron Ingot');
      await $('#save-btn').click();

      expect(await $$('.recipe-item')).toHaveLength(1);
  });

悪い例:
  UIテストなし（手動テストのみ）
```

**評価基準**:
| チェック項目 | ✓ |
|-------------|---|
| 主要なUI操作にE2Eテストがあるか | |
| CIで自動実行されるか | |
| スクリーンショット比較があるか | |

---

## Part 10: テストアンチパターン速見表

### 絶対に避ける

| パターン | 症状 | 対策 |
|----------|------|------|
| sleep固定待機 | 遅くて不安定 | 条件待機（poll） |
| 手動テストのみ | 回帰を見逃す | 自動化必須 |
| 巨大統合テスト | 遅くて脆い | 小さなユニットテスト |
| 非決定的テスト | 結果がバラバラ | シード固定 |

### 注意する

| パターン | 症状 | 対策 |
|----------|------|------|
| 画像マッチング依存 | 解像度で壊れる | セマンティック検証 |
| フレーム依存 | 環境で結果異なる | 論理フレームで検証 |
| 状態リーク | テスト間で干渉 | テストごとにリセット |
| カバレッジ至上主義 | 無意味なテスト増 | 重要パスに集中 |

---

## Part 11: テスト評価テンプレート

```markdown
## テストカバレッジ評価: [モジュール名]

### 基本情報
- 総テスト数:
- ユニットテスト数:
- 統合テスト数:
- E2Eテスト数:

### パターンチェック
| パターン | 適合 | 備考 |
|----------|------|------|
| T1. ECSユニットテスト | ☐ | |
| T2. リプレイシステム | ☐ | |
| T3. プロパティベース | ☐ | |
| T4. E2Eテスト | ☐ | |

### アンチパターンチェック
| アンチパターン | 該当 | 対策 |
|---------------|------|------|
| sleep固定待機 | ☐ | |
| 非決定的テスト | ☐ | |
| 状態リーク | ☐ | |

### 推奨アクション
-
```

---

*最終更新: 2025-12-22*
*ソース: factory-game-ux-research.md, factory-game-antipatterns.md, editor-ux-best-practices.md, editor-ux-antipatterns.md, testing-methods-research.md*
