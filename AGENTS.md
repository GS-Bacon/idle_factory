# AI Agent メモリ

このファイルは、AIエージェント（OpenAI Codex、GitHub Copilot、Gemini、Claude等）がこのプロジェクトで作業する際のガイドラインです。

## 用語定義（ユビキタス言語）

| 用語 | 意味 | コード上の対応 |
|------|------|---------------|
| **手持ちインベントリ** | プレイヤーが持ち歩くアイテム（ホットバー+バックパック） | `PlayerInventory` (Component) |
| **プラットフォームインベントリ** | 納品プラットフォームに紐づいた倉庫 | `PlatformInventory` (Component) |
| **収納** | コンベア経由でプラットフォームインベントリにアイテムが入ること | `TransferTarget::Delivery` |
| **納品** | クエストのためにプラットフォームインベントリからアイテムを消費すること | `quest_deliver_button` |

※ユーザーが混同していそうな場合は確認すること

## 作業ログ保存

「ログを保存」「作業ログを保存」と言われたら `WORK_LOG.md` に追記。

### 記録する内容

| 種類 | 記録する | 記録しない |
|------|----------|-----------|
| 設計議論 | 決定事項、理由、学び | 雑談、途中の迷い |
| 実装作業 | 完了タスク、技術判断 | 細かい試行錯誤 |
| バグ修正 | 原因、対策、再発防止 | デバッグ過程 |

### フォーマット

```markdown
## YYYY-MM-DD: タイトル

### 概要
1-2行で何をしたか

### 議論トピック / 完了タスク
- 箇条書きまたはテーブル

### 学び / 技術的判断
- 重要な決定とその理由
```

### 例

```markdown
## 2026-01-08: 設計議論セッション

### 概要
Mod API設計について議論。カテゴリ別集約方式に決定。

### 決定事項
| 項目 | 決定 | 理由 |
|------|------|------|
| API構成 | カテゴリ別集約 | マクロはデバッグ難 |

### 学び
- API追加は簡単、変更は既存Modを壊す
```

## Windowsへビルド送信（重要）

**トリガー**: 「windowsに送信」「windowsに送って」「windowsにビルド送信」等

**必ずこの手順を実行（他の方法は使わない）:**

```bash
# 1. Windowsパッケージをビルド（zip作成）
./scripts/build-packages.sh --windows-only

# 2. Tailscale経由でzipを送信（フォールバック付き）
tailscale file cp dist/idle_factory_*_windows.zip baconrogx13: || \
tailscale file cp dist/idle_factory_*_windows.zip smz-mousebook:
```

**送信先の優先順位:**
1. `baconrogx13` (メイン)
2. `smz-mousebook` (フォールバック)

**禁止事項:**
- exeだけ送る（assets/modsがないと動かない）
- GitHub Releasesにアップロード（聞かれていない）
- scp/rsync等の別手段（Tailscale file cpを使う）

**注意:**
- 両方オフラインなら `tailscale status` で確認してユーザーに報告
- Windows側でTailscale通知から保存→展開

## 互換性ポリシー

- **既存プレイヤーはいない** → セーブデータ移行は不要
- **しばらくは後方互換性を気にしなくてよい**
- 破壊的変更OK、古いセーブ切り捨てOK

## メタワーク判定基準（重要）

### メタワーク（やらない）

| 例 | 理由 |
|----|------|
| 仕様書を詳細化する | ゲームが1行も進まない |
| ドキュメント整理・圧縮 | 誰も読まない |
| ドキュメントコメント追加 | 誰も読まない |
| レビュースキル・パターン集作成 | 使わない道具 |
| コード移動だけのリファクタ | バグ確率変わらない |

### メタワークではない（やる）

| 例 | 理由 |
|----|------|
| 自動テスト追加 | バグを早期発見、開発速度UP |
| E2E強化 | 遊べないバグを防ぐ |
| CI/起動確認スクリプト | クラッシュを即検出 |
| バグ修正 | 遊べるようにする |
| リファクタ（複雑さ解消） | 将来のバグ確率を減らす |
| アーキテクチャ改善 | 機能追加時のバグ確率を減らす |
| 重複コード統合 | 片方だけ直して忘れるバグを防ぐ |
| 機能追加 | ゲームが進む |
| UI/UX改善 | 体験が良くなる |
| パフォーマンス改善 | 遊べる体験に直結 |

### 判定フロー

```
これをやると...
  → ゲームが遊べるようになる？ → やる
  → 今のバグが減る？ → やる
  → 将来のバグ確率が減る？ → やる
  → 機能追加が速くなる？ → やる
  → ドキュメントが増えるだけ？ → やらない
```

**過去の失敗**: 仕様39ファイル・パターン52個・レビュースキル群を作り、誰もゲームを遊んでいなかった

## 基本ルール

| ルール | 詳細 |
|--------|------|
| ビルド | `cargo build` (2秒)、テスト後 `cargo test && cargo clippy` |
| コミット | 日本語、短く。**コミットは自己判断でOK**、pushは指示待ち |
| 中断禁止 | 確認を求めず最後まで完了 |
| ゲーム起動 | `./run.sh` |
| バグ修正 | **再現テストなしの修正禁止**。下記参照 |
| **アーキテクチャ整合性** | コミット後に自動チェック。手動: `./scripts/architecture-check.sh` |

## アーキテクチャ整合性ルール

**自動チェック**: `git commit` 後に `post-commit` hookが自動実行

**手動チェック**:
```bash
./scripts/architecture-check.sh
```

**チェック内容**:
- ID方式の移行状態（ItemId使用箇所、MachineType残存）
- レガシーパターン（Res<PlayerInventory>等）
- モジュール構造の整合性

**アーキテクチャ変更時**:
1. `.claude/architecture.md` の該当セクションを更新
2. 移行状態テーブルを更新
3. `./scripts/architecture-check.sh` でエラーなしを確認

## 自律実行ルール（重要）

### 止まらずに続行すべき場面

| 状況 | 対応 |
|------|------|
| ビルドエラー | 自力で修正して続行 |
| テスト失敗 | 自力で修正して続行 |
| 設計判断が必要 | `.claude/architecture.md` に従って自己判断 |
| タスク完了 | **次のタスクへ自動で進む** |
| 軽微な問題 | 自己判断で解決して続行 |

### 止まって良い場面（これ以外は止まるな）

- **致命的エラーが3回連続で解決できない**
- **ユーザーに確認が必要と明記されている作業**（新ゲーム要素、UI/UX変更等）
- **pushの指示待ち**
- **指定された全タスクが完了した**

### タスク指定の書き方（ユーザー向け）

```
悪い例: 「Phase D をやって」（曖昧、どこで止まるか不明）
良い例: 「D.0〜D.5を全部完了するまで止まらず進めて」
良い例: 「implementation-plan.mdの未完了タスクを全部やって」
```

### 完了条件

- 指定されたタスク番号が全て ✅ になるまで続行
- 「次に進みますか？」「続けますか？」は**聞かない**
- 途中で寝落ちしても翌朝には完了している状態を目指す

## バグ修正ルール

1. **シナリオテストで再現**（`tests/scenarios/` にTOML作成）
2. テストが失敗することを確認
3. 修正する
4. テストがパスすることを確認
5. 関連テストも全部パスすることを確認

**禁止**: 「多分これが原因」で修正開始。必ずログかテストで原因特定してから。

### 「直りました」宣言ルール（必須）

**禁止**: コード変更だけで「直りました」と言う

**必須**: 以下のいずれかの証拠を示すこと
1. シナリオテストがパス（`node scripts/run-scenario.js`）
2. スクショで修正後の状態を見せる
3. ログ出力で正常動作を確認

**特にUI/ビジュアル系バグ**:
- 必ずスクショで確認
- 「見た目の問題」は目で見ないと確認できない

**修正ループ検知**:
- 同じファイルを3回編集しても直らない → 止まって報告
- 「直りました」→「直ってない」が2回続いた → 止まって報告

### シナリオテストの詳細

シナリオテストの書き方、利用可能なアクション、GameAction、検証可能なフィールドについては **[docs/scenario-test-guide.md](docs/scenario-test-guide.md)** を参照。

## 禁止事項

- 仕様だけのセッション2回連続
- 憶測での修正（ログ/スクリーンショットで確認してから）
- ドキュメント整理・圧縮作業

## UI実装ルール（必須）

### テキスト作成

| 禁止 | 必須 |
|------|------|
| `TextFont { font_size: X, ..default() }` | `text_font(font, size)` ヘルパー使用 |

**理由**: フォント指定忘れで日本語が文字化けする

### 設定画面への機能追加

| 禁止 | 必須 |
|------|------|
| 新しいルートパネル（別ウィンドウ）を作成 | `settings_ui.rs` の既存ヘルパー使用 |

**正しい追加方法** (`src/setup/ui/settings_ui.rs`):
```rust
spawn_section_header(panel, font, "セクション名");
spawn_slider(panel, font, "ラベル", SettingType::Xxx, min, max);
spawn_toggle(panel, font, "ラベル", SettingType::Xxx);
```

### UI階層ルール

| 追加したい機能 | 追加先 | 方法 |
|---------------|--------|------|
| ゲーム設定 | 設定画面内 | `settings_ui.rs` のヘルパー |
| システム通知 | 設定画面内 | `settings_ui.rs` に行追加 |
| ゲームプレイUI | HUD | `setup/ui/mod.rs` の `setup_ui()` |
| モーダルダイアログ | 独立パネル | `UIContext` 追加が必要（要相談） |

### 参照実装

- `src/setup/ui/mod.rs` - `text_font()`, `game_text()` ヘルパー
- `src/setup/ui/settings_ui.rs` - 設定セクション追加パターン
- `src/ui/machine_ui.rs` - 機械UIパターン

## 新機能実装

**確認が必要**: 新ゲーム要素、UI/UX変更、ゲームバランス変更
**確認不要**: バグ修正、リファクタリング、テスト追加

仕様は `src/game_spec.rs` に定義（Single Source of Truth）

### 機能追加時のテスト

新機能を実装したら、**シナリオテストを追加する**。詳細は [docs/scenario-test-guide.md](docs/scenario-test-guide.md) を参照。

## 検証の分担

| 担当 | 内容 |
|------|------|
| AI | ビルド、テスト、E2E、スクリーンショット確認、UI動作 |
| 人間 | ゲームプレイ体験（面白さ、直感性） |

## 開発フロー

```
ユーザー: 修正 → プッシュ → AI: プル → 作業 → プッシュ → ユーザー: 確認
```

## ツール

| ツール | 用途 | ヘルプ |
|--------|------|--------|
| `gemini <cmd>` | Gemini連携（アーキ設計、レビュー、数学検証） | `gemini --help` |
| `node scripts/run-scenario.js <file>` | シナリオテスト実行 | [docs/scenario-test-guide.md](docs/scenario-test-guide.md) |

※Gemini使用条件: Gemini 3/2.5モデルの時のみ（トークン制限でモデル切り替わったら使わない）

## AI出力品質基準

### 絶対禁止事項

1. ツール実行ログの混入（`| Read`, `| Glob`, `| Bash`で始まる行）
2. 未完成コード（`TODO`, `FIXME`, `unimplemented!()`）
3. 推測での引用（ファイルパス・関数名は確認してから）

### 出力量の最低基準

| タスクタイプ | 最低文字数 | 最低コード例数 |
|-------------|-----------|---------------|
| 設計ドキュメント | 3000字 | 5つ |
| コードレビュー | 2000字 | 各問題に修正例 |
| バグ調査 | 1500字 | テスト3件以上 |

### 出力構成の標準形式

1. サマリーテーブル（冒頭に必須）
2. 詳細セクション（`##`で分け）
3. コード例（各セクションに最低1つ）
4. 根拠（ファイル:行番号で引用）

### プロンプトアプローチ（効果検証済み）

| 順位 | アプローチ | 効果 | 使用場面 |
|------|-----------|------|---------|
| 1 | **例示プロンプト** | 高 | 品質を模倣させたい時 |
| 2 | 構造化プロンプト | 中 | 出力形式を安定させたい時 |
| 3 | タスク分割 | 中 | 複雑なタスクを確実にこなす時 |
| 4 | ロールベース | 低 | 特定観点（セキュリティ等）を強化したい時 |

## 参照ドキュメント

| ファイル | 内容 | 優先度 |
|----------|------|--------|
| **`.claude/architecture.md`** | **将来アーキテクチャ設計（権威ソース）** | **最優先** |
| `.claude/implementation-plan.md` | 統合実装計画（タスク一覧） | 高 |
| `.claude/bugs.md` | よくあるバグと対策 | 中 |
| `.specify/memory/constitution.md` | プロジェクト憲章 | 中 |
| `.specify/roadmap.md` | ロードマップ | 中 |
| `docs/scenario-test-guide.md` | シナリオテスト詳細 | 中 |

## 将来アーキテクチャ設計ルール（必須）

**`.claude/architecture.md` が全ての設計判断の権威ソース**

### 新規実装時

1. **必ず** `.claude/architecture.md` を参照
2. 将来設計と矛盾する実装は禁止
3. 将来設計にないパターンを使う場合は先に設計追記

### 禁止パターン（レガシー）

| 禁止 | 代替 |
|------|------|
| `PlayerInventory` (Resource) | `Inventory` (Component) + `LocalPlayer(Entity)` |
| 個別機械ファイル (`furnace.rs`等) | `machines/generic.rs` |
| `InteractingFurnace/Crusher/Miner` | `InteractingMachine(Option<Entity>)` |
| ハードコード機械ロジック | `MachineSpec` + データ駆動 |
| ~~`BlockType` 直接参照~~ | `ItemId` に完全移行済み |

### 整理対象

古い実装・タスク・ドキュメントを見つけたら：
1. 将来設計と照合
2. 矛盾があれば将来設計に従って修正
3. 不要なら削除

## タスク完了の定義（重要）

### ドキュメント更新ルール

**タスク完了時に必ず更新するファイル:**

| 作業種類 | 更新対象 |
|----------|----------|
| バグ修正 | `.claude/bugs.md` → `.claude/implementation-plan.md` → `.specify/roadmap.md` |
| 機能実装 | `.claude/implementation-plan.md` → `.specify/roadmap.md` |
| マイルストーン完了 | 上記 + `CLAUDE.md` の「現在の状態」 |

**チェックコマンド:**
```bash
./scripts/sync-check.sh
```

**よくある失敗:**
- bugs.mdで「修正済み」にしたが、implementation-planは未更新
- タスクを完了したが、roadmap.mdの状態が古いまま

**齟齬修正時の記録（必須）:**
```bash
# 齟齬を修正したら必ず追記
echo "$(date +%Y-%m-%d): 修正内容" >> .claude/doc-sync-fixes.log
```

**10回超えたら構造化データ管理へ移行検討** - `.claude/doc-sync-fixes.log` が10行を超えたら `tasks.toml` ベースの管理を提案すること

### 「基盤実装」と「移行完了」は別物

| 状態 | マーク | 意味 | 例 |
|------|--------|------|-----|
| 未着手 | ❌ | 何もしていない | - |
| 基盤実装 | 🔨 | 型・構造体を作った | `Id<T>`を定義した |
| 移行中 | 🔄 | 既存コードを書き換え中 | 100/566箇所完了 |
| 完了 | ✅ | **古い実装が0件** | `grep BlockType` が0件 |

### 完了条件チェック

```bash
# 移行状況を確認
./scripts/migration-status.sh

# 詳細表示
./scripts/migration-status.sh -v
```

### 禁止

- **基盤だけ作って「完了」にする** ← これが過去の問題
- 移行作業を別タスクに先送り
- 数字を確認せずに「完了」マーク

### タスク定義の書き方

```markdown
## D.X: タスク名

**ステータス**: 🔨 基盤実装済み

### 完了条件（全て満たすこと）
- [ ] `grep -r 'OldPattern' src` が 0件
- [ ] 新パターンのテストが存在
- [ ] `./scripts/migration-status.sh` で該当項目が ✅

### Phase 1: 基盤 ✅
- [x] 新しい型を定義

### Phase 2: 移行 ❌ (0/100箇所)
- [ ] ファイルA (0/30)
- [ ] ファイルB (0/70)
```

## 修正済みバグ

BUG-1〜9: 全て修正済み。詳細は `.claude/bugs.md` 参照。

## バイブコーディング限界実験

このプロジェクトは「非エンジニアがAIだけで大規模ゲームを作れるか」の実験。

### 記録ルール

**マイルストーンごとに作業ログへ以下を追記：**

| 項目 | 内容 |
|------|------|
| コード行数 | `wc -l src/**/*.rs` |
| テスト数 | `cargo test 2>&1 \| grep "test result"` |
| 破綻の兆候 | 同じバグ再発、AIが矛盾した修正、無限ループなど |
| 人間介入 | 何を判断したか、なぜAIだけでは無理だったか |
| 回復方法 | どうやって立て直したか |

### 観測すべき破綻パターン

1. **コンテキスト限界** - AIが以前の決定を忘れる
2. **メタワーク暴走** - ゲームが進まずドキュメントだけ増える
3. **修正ループ** - AIがAIの書いたコードを直す無限ループ
4. **設計の不整合** - モジュール間で噛み合わない

### 暴走検知ルール

```
AIが1時間作業したら → ゲームを起動して変化を見せる
変化がない or 説明が長い → 暴走の兆候
```

### 定期リファクタリング

**マイルストーンごとに実行：**

```
「現在のプロジェクト構造を要約し、不要な複雑性を指摘せよ」
```

チェックポイント：
- 1000行超えファイルがないか
- 重複コードがないか
- 使われていないコードがないか
- テストカバレッジが落ちていないか

## 現在の状態

| 項目 | 値 |
|------|-----|
| バージョン | **0.3.184** |
| コード行数 | **29,253行** |
| テスト | **613件** 通過 |
| Clippy警告 | **0件** |
| 移行状態 | **✅ 新アーキ完全移行済み** |

## タスク

**詳細は `.claude/implementation-plan.md` 参照**

### 完了済み基盤

| タスク | 確認方法 |
|--------|----------|
| LocalPlayer Entity化 | 47箇所で使用 |
| PlayerInventory Component化 | `Res<PlayerInventory>` 0件 |
| MachineBundle使用 | 23箇所で使用 |
| GuardedEventWriter使用 | 16箇所で使用 |
| WebSocket API (port 9877) | 18メソッド実装済み |
| レガシー機械削除 | 旧struct 0件 |
| パニック防止 (P.0-P.4) | フォールバック実装済み |
| 固定Tick (20Hz) | FixedUpdate使用 |
| **BlockType→ItemId移行** | ✅ **0箇所（完全削除）** |
| **WASM Mod基盤 (M2)** | ✅ **8ファイル、ホスト関数実装済み** |

### 次のステップ（ユーザー判断）

| 機能 | 内容 |
|------|------|
| 電力システム | M3: 発電機→電線→機械 |
| 液体・気体 | M4: パイプ、タンク |
| 信号制御 | M4: 論理回路 |

**決定済み設計** (`.claude/architecture.md` 参照):
- 動的ID: `ItemId` (完全移行済み)
- Mod API: WebSocket + TOML + WASM (M2完了)
- マルチ対応: Component化済み

## Active Technologies
- Rust 1.75+ + Bevy 0.14+, Wasmtime (既に使用) (001-power-system-spec)
- Bevy ECS components + セーブファイル（V2形式） (001-power-system-spec)

## Recent Changes
- 001-power-system-spec: Added Rust 1.75+ + Bevy 0.14+, Wasmtime (既に使用)
