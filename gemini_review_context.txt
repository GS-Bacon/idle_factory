# Idle Factory - コードレビュー依頼

## プロジェクト概要
Bevy (Rust) で作成したボクセルゲーム。Minecraft風の採掘・工場建設ゲーム。

## 現在の統計
- 総コード行数: 約12,000行
- テスト: 91件通過
- モジュール数: 約30

## アーキテクチャ
- ECS (Entity Component System) パターン
- プラグインベース (MachineSystemsPlugin, UIPlugin, SavePlugin)
- チャンクベースのワールド生成

## レビュー対象
以下のmain.rsと、プロジェクト全体の設計についてレビューしてください。

### 評価基準
1. コード品質 (可読性、保守性)
2. アーキテクチャ設計
3. Bevy/ECSのベストプラクティス準拠
4. パフォーマンス考慮
5. テスト網羅性
6. 改善提案

### 10点満点で総合評価もお願いします。

---
## main.rs (384行)
//! Idle Factory - Milestone 1: Minimal Voxel Game
//! Goal: Walk, mine blocks, collect in inventory

mod block_type;
mod components;
mod constants;
mod events;
mod game_spec;
mod logging;
mod meshes;
mod player;
mod plugins;
mod save;
pub mod setup;
mod systems;
mod ui;
mod utils;
mod vox_loader;
mod world;

// Re-export components for use by other modules via crate::ComponentName
pub use components::*;
use events::GameEventsPlugin;
#[cfg(target_arch = "wasm32")]
use logging::GameLoggingPlugin;
use player::Inventory;
use plugins::{MachineSystemsPlugin, SavePlugin, UIPlugin};
use setup::{setup_initial_items, setup_lighting, setup_player, setup_ui};
use utils::ray_aabb_intersection;
use systems::{
    // Block operation systems
    block_break, block_place,
    // Player systems
    player_look, player_move, tick_action_timers, toggle_cursor_lock, tutorial_dismiss,
    // Chunk systems
    receive_chunk_meshes, spawn_chunk_tasks, unload_distant_chunks,
    // UI systems (not in UIPlugin)
    select_block_type, set_ui_open_state, update_window_title_fps, export_e2e_state,
    E2EExportConfig, TeleportEvent, LookEvent, SetBlockEvent, handle_teleport_event,
    handle_look_event, handle_setblock_event, handle_spawn_machine_event, handle_debug_conveyor_event,
    DebugConveyorEvent,
    // Quest systems
    load_machine_models, quest_claim_rewards, quest_progress_check, setup_delivery_platform,
    update_delivery_ui, update_quest_ui,
    // Targeting systems
    rotate_conveyor_placement, update_conveyor_shapes, update_guide_markers,
    update_target_block, update_target_highlight,
};
use world::{ChunkMesh, ChunkMeshTasks, WorldData};

use bevy::diagnostic::FrameTimeDiagnosticsPlugin;
use bevy::prelude::*;
#[cfg(not(target_arch = "wasm32"))]
use bevy::render::pipelined_rendering::PipelinedRenderingPlugin;
#[cfg(not(target_arch = "wasm32"))]
use bevy::window::PresentMode;

pub use block_type::BlockType;
pub use constants::*;

fn main() {
    // WASM: Set panic hook to display errors in browser console
    #[cfg(target_arch = "wasm32")]
    console_error_panic_hook::set_once();

    // Initialize logging before anything else
    #[cfg(not(target_arch = "wasm32"))]
    let _log_guard = logging::init_logging();

    let mut app = App::new();

    // Configure plugins based on platform
    #[cfg(not(target_arch = "wasm32"))]
    {
        // Native: Disable pipelined rendering for lower input lag
        // Disable LogPlugin to use custom tracing-subscriber instead
        use bevy::log::LogPlugin;
        // Use current working directory for assets (not executable path)
        app.add_plugins((
            DefaultPlugins
                .build()
                .disable::<PipelinedRenderingPlugin>()
                .disable::<LogPlugin>()
                .set(AssetPlugin {
                    file_path: "assets".to_string(),
                    ..default()
                })
                .set(WindowPlugin {
                    primary_window: Some(Window {
                        title: "Idle Factory".into(),
                        present_mode: PresentMode::AutoNoVsync,
                        desired_maximum_frame_latency: std::num::NonZeroU32::new(1),
                        ..default()
                    }),
                    ..default()
                }),
            FrameTimeDiagnosticsPlugin,
        ));
    }

    #[cfg(target_arch = "wasm32")]
    {
        // WASM: Use default plugins with canvas selector
        // Disable LogPlugin to use tracing_wasm instead
        use bevy::log::LogPlugin;
        app.add_plugins((
            DefaultPlugins
                .build()
                .disable::<LogPlugin>()
                .set(WindowPlugin {
                    primary_window: Some(Window {
                        title: "Idle Factory".into(),
                        canvas: Some("#bevy-canvas".to_string()),
                        fit_canvas_to_parent: true,
                        prevent_default_event_handling: true,
                        ..default()
                    }),
                    ..default()
                }),
            FrameTimeDiagnosticsPlugin,
        ));
    }

    // WASM: Add logging plugin (Native logging is initialized above)
    #[cfg(target_arch = "wasm32")]
    app.add_plugins(GameLoggingPlugin);

    // Add VOX loader plugin for hot reload (native only)
    #[cfg(not(target_arch = "wasm32"))]
    app.add_plugins(vox_loader::VoxLoaderPlugin);

    app
        .add_plugins(GameEventsPlugin)
        .add_plugins(MachineSystemsPlugin)
        .add_plugins(UIPlugin)
        .add_plugins(SavePlugin)
        .init_resource::<Inventory>()
        .init_resource::<WorldData>()
        .init_resource::<CursorLockState>()
        .init_resource::<CurrentQuest>()
        .init_resource::<GameFont>()
        .init_resource::<ChunkMeshTasks>()
        .init_resource::<CreativeMode>()
        .init_resource::<ContinuousActionTimer>()
        .init_resource::<E2EExportConfig>()
        .add_event::<TeleportEvent>()
        .add_event::<LookEvent>()
        .add_event::<SetBlockEvent>()
        .add_event::<DebugConveyorEvent>()
        .add_systems(Startup, (setup_lighting, setup_player, setup_ui, setup_initial_items, setup_delivery_platform, load_machine_models))
        .add_systems(
            Update,
            (
                // Core gameplay systems - chunk loading
                spawn_chunk_tasks,
                receive_chunk_meshes,
                unload_distant_chunks,
                toggle_cursor_lock,
                player_look,
                player_move,
                tick_action_timers,
            ),
        )
        .add_systems(Update, tutorial_dismiss)
        .add_systems(Update, block_break)
        .add_systems(Update, block_place)
        .add_systems(Update, select_block_type)
        .add_systems(
            Update,
            (
                // Quest systems
                systems::targeting::update_conveyor_shapes,
                quest_progress_check,
                quest_claim_rewards,
            ),
        )
        .add_systems(
            Update,
            (
                // Quest UI systems
                update_delivery_ui,
                update_quest_ui,
                update_window_title_fps,
            ),
        )
        .add_systems(
            Update,
            (
                // Debug and targeting systems
                export_e2e_state,
                update_target_block,
                update_target_highlight,
                rotate_conveyor_placement,
                update_conveyor_shapes,
                update_guide_markers,
            ),
        )
        .add_systems(
            Update,
            (
                // E2E command handlers
                handle_teleport_event,
                handle_look_event,
                handle_setblock_event,
                handle_spawn_machine_event,
                handle_debug_conveyor_event,
            ),
        )
        .run();
}

// === Tests ===

#[cfg(test)]
mod tests {
    use super::*;
    use world::ChunkData;
    use crate::systems::get_quests;
    use crate::utils::ray_aabb_intersection_with_normal;

    #[test]
    fn test_chunk_generation() {
        let chunk = ChunkData::generate(IVec2::ZERO);
        assert!(!chunk.blocks_map.is_empty());
        let surface_block = chunk.blocks_map.get(&IVec3::new(0, 7, 0));
        assert!(matches!(
            surface_block,
            Some(BlockType::Grass) | Some(BlockType::IronOre) | Some(BlockType::CopperOre) | Some(BlockType::Coal)
        ));
    }

    #[test]
    fn test_world_coordinate_conversion() {
        assert_eq!(WorldData::world_to_chunk(IVec3::new(0, 0, 0)), IVec2::new(0, 0));
        assert_eq!(WorldData::world_to_chunk(IVec3::new(16, 0, 0)), IVec2::new(1, 0));
        assert_eq!(WorldData::world_to_chunk(IVec3::new(-1, 0, -1)), IVec2::new(-1, -1));
    }

    #[test]
    fn test_world_data_block_operations() {
        let mut world = WorldData::default();
        world.chunks.insert(IVec2::new(0, 0), ChunkData::generate(IVec2::ZERO));
        assert!(world.has_block(IVec3::new(0, 0, 0)));
        assert!(!world.has_block(IVec3::new(0, 10, 0)));
    }

    #[test]
    fn test_mesh_winding_order() {
        let mut world = WorldData::default();
        let chunk_coord = IVec2::new(0, 0);
        world.chunks.insert(chunk_coord, ChunkData::generate(chunk_coord));
        let mesh = world.generate_chunk_mesh(chunk_coord).unwrap();
        let positions = match mesh.attribute(Mesh::ATTRIBUTE_POSITION).unwrap() {
            bevy::render::mesh::VertexAttributeValues::Float32x3(v) => v.clone(),
            _ => panic!("Unexpected vertex format"),
        };
        let indices = match mesh.indices().unwrap() {
            bevy::render::mesh::Indices::U32(v) => v.clone(),
            _ => panic!("Unexpected index format"),
        };
        let normals = match mesh.attribute(Mesh::ATTRIBUTE_NORMAL).unwrap() {
            bevy::render::mesh::VertexAttributeValues::Float32x3(v) => v.clone(),
            _ => panic!("Unexpected normal format"),
        };
        let mut correct = 0;
        let mut total = 0;
        for tri in indices.chunks(3) {
            let v0 = Vec3::from_array(positions[tri[0] as usize]);
            let v1 = Vec3::from_array(positions[tri[1] as usize]);
            let v2 = Vec3::from_array(positions[tri[2] as usize]);
            let cross = (v1 - v0).cross(v2 - v0);
            if cross.length() < 0.0001 { continue; }
            let calc_normal = cross.normalize();
            let expected = Vec3::from_array(normals[tri[0] as usize]);
            total += 1;
            if calc_normal.dot(expected) > 0.9 { correct += 1; }
        }
        assert!(correct as f32 / total as f32 > 0.99);
    }

    #[test]
    fn test_inventory_add() {
        let mut inventory = Inventory::default();
        inventory.add_item(BlockType::Stone, 1);
        assert_eq!(inventory.get_item_count(BlockType::Stone), 1);
    }

    #[test]
    fn test_ray_aabb_hit() {
        let result = ray_aabb_intersection(
            Vec3::new(0.0, 0.0, -5.0),
            Vec3::new(0.0, 0.0, 1.0),
            Vec3::new(-1.0, -1.0, -1.0),
            Vec3::new(1.0, 1.0, 1.0),
        );
        assert!(result.is_some());
    }

    #[test]
    fn test_ray_aabb_with_normal_z() {
        let result = ray_aabb_intersection_with_normal(
            Vec3::new(0.0, 0.0, -5.0),
            Vec3::new(0.0, 0.0, 1.0),
            Vec3::new(-1.0, -1.0, -1.0),
            Vec3::new(1.0, 1.0, 1.0),
        );
        assert!(result.is_some());
        let (_, normal) = result.unwrap();
        assert_eq!(normal, Vec3::NEG_Z);
    }

    #[test]
    fn test_hotbar_scroll_stays_in_bounds() {
        assert_eq!(HOTBAR_SLOTS, 9);
        assert_eq!(NUM_SLOTS, 36);
        for start_slot in 0..HOTBAR_SLOTS {
            let next = (start_slot + 1) % HOTBAR_SLOTS;
            assert!(next < HOTBAR_SLOTS);
        }
    }

    #[test]
    fn test_inventory_consumption() {
        let mut inventory = Inventory::default();
        inventory.add_item(BlockType::Stone, 10);
        inventory.selected_slot = 0;
        assert_eq!(inventory.get_slot_count(0), 10);
        inventory.consume_selected();
        assert_eq!(inventory.get_slot_count(0), 9);
    }

    #[test]
    fn test_mode_constants() {
        let creative = CreativeMode::default();
        assert!(!creative.enabled);
    }

    #[test]
    fn test_quest_rewards() {
        let quests = get_quests();
        assert!(!quests.is_empty());
        for quest in &quests {
            assert!(quest.required_amount > 0);
        }
    }

    #[test]
    fn test_input_state_priority() {
        let state = InputState::current(
            &InventoryOpen(false),
            &InteractingFurnace(None),
            &InteractingCrusher(None),
            &InteractingMiner(None),
            &CommandInputState::default(),
            &CursorLockState::default(),
        );
        assert!(matches!(state, InputState::Gameplay));

        let state = InputState::current(
            &InventoryOpen(true),
            &InteractingFurnace(None),
            &InteractingCrusher(None),
            &InteractingMiner(None),
            &CommandInputState::default(),
            &CursorLockState { paused: true, ..default() },
        );
        assert!(matches!(state, InputState::Paused));
    }

    #[test]
    fn test_input_state_allows() {
        assert!(InputState::Gameplay.allows_movement());
        assert!(InputState::Gameplay.allows_block_actions());
        assert!(!InputState::Inventory.allows_movement());
        assert!(!InputState::Command.allows_block_actions());
    }

    #[test]
    fn test_biome_generation() {
        let biome1 = ChunkData::get_biome(0, 0);
        let biome2 = ChunkData::get_biome(0, 0);
        assert_eq!(biome1, biome2);
    }
}

---
## プロジェクト構造
/home/bacon/idle_factory/src/world/mod.rs
/home/bacon/idle_factory/src/components/machines.rs
/home/bacon/idle_factory/src/components/player.rs
/home/bacon/idle_factory/src/components/mod.rs
/home/bacon/idle_factory/src/components/input.rs
/home/bacon/idle_factory/src/components/ui.rs
/home/bacon/idle_factory/src/game_spec.rs
/home/bacon/idle_factory/src/main.rs
/home/bacon/idle_factory/src/plugins/machines.rs
/home/bacon/idle_factory/src/plugins/mod.rs
/home/bacon/idle_factory/src/plugins/save.rs
/home/bacon/idle_factory/src/plugins/ui.rs
/home/bacon/idle_factory/src/utils.rs
/home/bacon/idle_factory/src/block_type.rs
/home/bacon/idle_factory/src/constants.rs
/home/bacon/idle_factory/src/logging.rs
/home/bacon/idle_factory/src/player/inventory.rs
/home/bacon/idle_factory/src/player/mod.rs
/home/bacon/idle_factory/src/ui/mod.rs
/home/bacon/idle_factory/src/setup/initial_items.rs
/home/bacon/idle_factory/src/setup/lighting.rs
/home/bacon/idle_factory/src/setup/player.rs
/home/bacon/idle_factory/src/setup/mod.rs
/home/bacon/idle_factory/src/events/mod.rs
/home/bacon/idle_factory/src/systems/crusher.rs
/home/bacon/idle_factory/src/systems/inventory_ui.rs
/home/bacon/idle_factory/src/systems/conveyor.rs
/home/bacon/idle_factory/src/systems/furnace.rs
/home/bacon/idle_factory/src/systems/hotbar.rs
/home/bacon/idle_factory/src/systems/debug_ui.rs
/home/bacon/idle_factory/src/systems/save_systems.rs
/home/bacon/idle_factory/src/systems/player.rs
/home/bacon/idle_factory/src/systems/chunk.rs
/home/bacon/idle_factory/src/systems/miner.rs
/home/bacon/idle_factory/src/systems/mod.rs
/home/bacon/idle_factory/src/systems/quest.rs
/home/bacon/idle_factory/src/systems/command_ui.rs
/home/bacon/idle_factory/src/vox_loader.rs
/home/bacon/idle_factory/src/save.rs
/home/bacon/idle_factory/src/meshes.rs

---
## ファイルサイズ一覧（上位15）
  7279 total
   826 /home/bacon/idle_factory/src/systems/command_ui.rs
   648 /home/bacon/idle_factory/src/systems/inventory_ui.rs
   627 /home/bacon/idle_factory/src/world/mod.rs
   524 /home/bacon/idle_factory/src/systems/conveyor.rs
   518 /home/bacon/idle_factory/src/systems/save_systems.rs
   400 /home/bacon/idle_factory/src/systems/debug_ui.rs
   381 /home/bacon/idle_factory/src/player/inventory.rs
   374 /home/bacon/idle_factory/src/components/machines.rs
   324 /home/bacon/idle_factory/src/systems/miner.rs
   319 /home/bacon/idle_factory/src/systems/furnace.rs
   316 /home/bacon/idle_factory/src/systems/crusher.rs
   312 /home/bacon/idle_factory/src/systems/chunk.rs
   270 /home/bacon/idle_factory/src/systems/quest.rs
   270 /home/bacon/idle_factory/src/systems/player.rs
