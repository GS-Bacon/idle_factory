<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Idle Factory</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a1a2e;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #eee;
            font-family: sans-serif;
            font-size: 24px;
            text-align: center;
        }
        .progress-container {
            width: 300px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            margin: 20px auto;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #44a08d);
            width: 0%;
            transition: width 0.1s;
        }
        .progress-text {
            font-size: 14px;
            color: #888;
            margin-top: 10px;
        }
        #bevy-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
        }
        #pointer-lock-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            cursor: pointer;
        }
        #pointer-lock-overlay .message {
            background: rgba(0,0,0,0.8);
            color: #fff;
            padding: 30px 50px;
            border-radius: 10px;
            font-family: sans-serif;
            font-size: 20px;
            text-align: center;
        }
        #pointer-lock-overlay .hint {
            font-size: 14px;
            color: #aaa;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <canvas id="bevy-canvas"></canvas>
    <div id="pointer-lock-overlay">
        <div class="message">
            Click to Resume
            <div class="hint">Press ESC to pause</div>
        </div>
    </div>
    <div id="loading">
        <div>Idle Factory</div>
        <div class="progress-container">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
        <div class="progress-text" id="progress-text">Preparing...</div>
    </div>
    <div id="controls">
        <b>Controls:</b><br>
        WASD - Move | Mouse - Look<br>
        Left Click - Break | Right Click - Place<br>
        1-4 - Select Item | E - Furnace UI<br>
        Q - Claim Quest Reward
    </div>
    <script type="module">
        import init from './idle_factory.js';

        // === Analytics / Logging ===
        const gameLog = {
            sessionId: Date.now().toString(36) + Math.random().toString(36).substr(2, 5),
            startTime: Date.now(),
            ua: navigator.userAgent,
            screen: { w: screen.width, h: screen.height, dpr: devicePixelRatio },
            events: [],
            fps: [],
            errors: []
        };

        function logEvent(type, data = {}) {
            gameLog.events.push({ t: Date.now() - gameLog.startTime, type, ...data });
        }

        // Track FPS with freeze detection
        let lastFrameTime = performance.now();
        let lastRafTime = performance.now();
        let frameCount = 0;
        let freezeDetected = false;
        const FREEZE_THRESHOLD_MS = 3000; // 3秒フレームなし = フリーズ

        function trackFps() {
            frameCount++;
            const now = performance.now();
            lastRafTime = now;
            freezeDetected = false;

            if (now - lastFrameTime >= 5000) { // Every 5 seconds
                const fps = Math.round(frameCount / ((now - lastFrameTime) / 1000));
                gameLog.fps.push({ t: Date.now() - gameLog.startTime, fps });
                frameCount = 0;
                lastFrameTime = now;
            }
            requestAnimationFrame(trackFps);
        }

        // Freeze detection - check if rAF stopped
        setInterval(() => {
            const now = performance.now();
            const timeSinceLastFrame = now - lastRafTime;

            if (timeSinceLastFrame > FREEZE_THRESHOLD_MS && !freezeDetected) {
                freezeDetected = true;
                const freezeData = {
                    t: Date.now() - gameLog.startTime,
                    duration: timeSinceLastFrame,
                    lastFps: gameLog.fps.length > 0 ? gameLog.fps[gameLog.fps.length - 1].fps : null
                };
                gameLog.errors.push({ ...freezeData, type: 'FREEZE' });
                logEvent('freeze_detected', freezeData);

                // Auto-save to localStorage
                saveLogsToStorage('freeze');
                console.error('FREEZE DETECTED:', freezeData);
            }
        }, 1000);

        // Save logs to localStorage
        function saveLogsToStorage(reason = 'manual') {
            try {
                const key = `gameLog_${gameLog.sessionId}`;
                gameLog.savedAt = Date.now();
                gameLog.saveReason = reason;
                localStorage.setItem(key, JSON.stringify(gameLog));

                // Keep list of all sessions
                const sessions = JSON.parse(localStorage.getItem('gameSessions') || '[]');
                if (!sessions.includes(gameLog.sessionId)) {
                    sessions.push(gameLog.sessionId);
                    // Keep only last 20 sessions
                    while (sessions.length > 20) {
                        const oldId = sessions.shift();
                        localStorage.removeItem(`gameLog_${oldId}`);
                    }
                    localStorage.setItem('gameSessions', JSON.stringify(sessions));
                }
            } catch (e) {
                console.warn('Failed to save logs:', e);
            }
        }

        // Export all logs for analysis
        window.exportGameLogs = function() {
            const sessions = JSON.parse(localStorage.getItem('gameSessions') || '[]');
            const allLogs = sessions.map(id => {
                const log = localStorage.getItem(`gameLog_${id}`);
                return log ? JSON.parse(log) : null;
            }).filter(Boolean);

            const blob = new Blob([JSON.stringify(allLogs, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `game-logs-${new Date().toISOString().slice(0,10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
            return allLogs;
        };

        // Show freeze summary
        window.showFreezeLogs = function() {
            const sessions = JSON.parse(localStorage.getItem('gameSessions') || '[]');
            const freezes = [];
            sessions.forEach(id => {
                const log = localStorage.getItem(`gameLog_${id}`);
                if (log) {
                    const parsed = JSON.parse(log);
                    const sessionFreezes = parsed.errors.filter(e => e.type === 'FREEZE');
                    if (sessionFreezes.length > 0) {
                        freezes.push({
                            sessionId: id,
                            startTime: new Date(parsed.startTime).toISOString(),
                            freezes: sessionFreezes,
                            lastEvents: parsed.events.slice(-10)
                        });
                    }
                }
            });
            console.table(freezes);
            return freezes;
        };

        console.log('Debug commands: exportGameLogs(), showFreezeLogs()');

        // Track errors
        window.addEventListener('error', (e) => {
            gameLog.errors.push({ t: Date.now() - gameLog.startTime, msg: e.message, src: e.filename });
        });

        // Track key presses (game actions only)
        const trackedKeys = new Set(['w','a','s','d','e','q','1','2','3','4','escape']);
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (trackedKeys.has(key)) {
                logEvent('key', { k: key });
            }
            // Note: ESC automatically exits pointer lock (browser behavior)
            // No need to call document.exitPointerLock() manually
        });

        // Pointer Lock management
        const canvas = document.getElementById('bevy-canvas');
        const pointerLockOverlay = document.getElementById('pointer-lock-overlay');
        let gameStarted = false;
        let pointerLockActive = false;

        function requestPointerLockSafe() {
            if (!document.pointerLockElement) {
                canvas.requestPointerLock().catch(err => {
                    console.warn('Pointer lock request failed:', err);
                });
            }
        }

        function showOverlay() {
            if (gameStarted) {
                pointerLockOverlay.style.display = 'flex';
            }
        }

        function hideOverlay() {
            pointerLockOverlay.style.display = 'none';
        }

        // Track mouse clicks and handle pointer lock
        window.addEventListener('mousedown', (e) => {
            logEvent('click', { btn: e.button });
        });

        // Click on canvas or overlay to request pointer lock
        canvas.addEventListener('click', () => {
            if (gameStarted && !document.pointerLockElement) {
                requestPointerLockSafe();
            }
        });

        pointerLockOverlay.addEventListener('click', () => {
            requestPointerLockSafe();
        });

        // Handle pointer lock change
        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === canvas) {
                pointerLockActive = true;
                hideOverlay();
                logEvent('pointer_locked');
            } else {
                pointerLockActive = false;
                showOverlay();
                logEvent('pointer_unlocked');
            }
        });

        // Handle pointer lock error
        document.addEventListener('pointerlockerror', () => {
            console.warn('Pointer lock error');
            logEvent('pointer_lock_error');
            showOverlay();
        });

        // Send logs periodically and on page unload
        function sendLogs() {
            const data = JSON.stringify(gameLog);
            fetch('/game-log', {
                method: 'POST',
                body: data,
                headers: { 'Content-Type': 'application/json' }
            }).catch(() => {});
        }

        setInterval(sendLogs, 30000); // Every 30 seconds
        window.addEventListener('beforeunload', () => {
            saveLogsToStorage('unload');
            sendLogs();
        });
        window.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                saveLogsToStorage('hidden');
                sendLogs();
            }
        });

        async function run() {
            const loadingEl = document.getElementById('loading');
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');

            function setProgress(percent, text) {
                progressBar.style.width = percent + '%';
                progressText.textContent = text;
            }

            try {
                // Fetch WASM with progress
                setProgress(0, 'Downloading WASM...');
                const wasmResponse = await fetch('./idle_factory_bg.wasm');
                const contentLength = wasmResponse.headers.get('Content-Length');
                const total = parseInt(contentLength, 10) || 30000000; // ~30MB fallback

                let loaded = 0;
                const reader = wasmResponse.body.getReader();
                const chunks = [];

                while (true) {
                    const {done, value} = await reader.read();
                    if (done) break;
                    chunks.push(value);
                    loaded += value.length;
                    const percent = Math.min(90, Math.round((loaded / total) * 90));
                    setProgress(percent, `Downloading... ${(loaded / 1024 / 1024).toFixed(1)}MB`);
                }

                setProgress(92, 'Compiling WASM...');
                const wasmBytes = new Uint8Array(loaded);
                let offset = 0;
                for (const chunk of chunks) {
                    wasmBytes.set(chunk, offset);
                    offset += chunk.length;
                }

                setProgress(95, 'Initializing...');
                await init(wasmBytes);

                setProgress(100, 'Starting game...');
                loadingEl.style.display = 'none';
                gameStarted = true;
                showOverlay(); // Show "Click to start" overlay
                logEvent('game_started');
                trackFps(); // Start FPS tracking
            } catch (e) {
                // winit uses exceptions for control flow - this is normal, not an error
                if (e.toString().includes("Using exceptions for control flow")) {
                    console.log("Game started (winit control flow exception - this is normal)");
                    loadingEl.style.display = 'none';
                    gameStarted = true;
                    showOverlay(); // Show "Click to start" overlay
                    logEvent('game_started');
                    trackFps(); // Start FPS tracking
                    return;
                }

                const errorMsg = e.toString() + '\n\nStack: ' + (e.stack || 'N/A');
                loadingEl.innerHTML =
                    '<div style="color: #ff6b6b; font-size: 20px;">Error loading game</div>' +
                    '<pre style="font-size: 11px; margin-top: 15px; text-align: left; max-width: 90vw; overflow: auto; background: #222; padding: 10px; border-radius: 5px;">' +
                    errorMsg.replace(/</g, '&lt;') + '</pre>' +
                    '<div style="font-size: 12px; margin-top: 15px; color: #888;">WebGL2 required. Try Chrome/Firefox on PC.</div>';
                console.error('WASM Error:', e);
            }
        }

        run();
    </script>
</body>
</html>
